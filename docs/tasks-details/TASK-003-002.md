# TASK-003-002: Integrate Writer with OrcaRunner

**Phase**: Phase 1 - Output File Persistence  
**Priority**: P0 (Blocker)  
**Estimated Effort**: 2 hours  
**Assigned To**: TBD  
**Status**: Not Started

---

## Overview

Integrate the `OutputFileWriter` class into the existing `OrcaRunner.runOrcaJob()` method to enable automatic `.out` file creation during ORCA execution. This task connects the file writing infrastructure with the actual job execution pipeline.

---

## Dependencies

**Blocked By**: 
- TASK-003-001 (OutputFileWriter class must exist)

**Blocks**:
- TASK-003-004 (Real-time file writing relies on this integration)
- TASK-003-005 (Unit tests for complete integration)

---

## Objectives

1. Import and instantiate `OutputFileWriter` in `OrcaRunner`
2. Wire stdout/stderr to both output channel and file writer
3. Ensure proper lifecycle management (initialize, write, close)
4. Handle errors without disrupting existing functionality
5. Read configuration setting for enable/disable

---

## Technical Specifications

### File to Modify
`src/orcaRunner.ts`

### Integration Architecture

```
ORCA Process (spawn)
    ↓
  stdout/stderr events
    ↓
    ├─→ OutputChannel.append() [existing]
    └─→ OutputFileWriter.write() [NEW]
```

### Code Changes

#### 1. Add Import Statement
```typescript
import { OutputFileWriter } from './outputWriter';
```

#### 2. Add Class Property
```typescript
export class OrcaRunner {
  private currentProcess: child_process.ChildProcess | null = null;
  private outputChannel: vscode.OutputChannel;
  private statusBarItem: vscode.StatusBarItem;
  private fileWatcher: fs.FSWatcher | null = null;
  private outputWriter: OutputFileWriter | null = null; // NEW
```

#### 3. Modify runOrcaJob() Method

**Before stdout handler** (around line 80-90):
```typescript
public async runOrcaJob(document: vscode.TextDocument): Promise<void> {
  // ... existing validation code ...
  
  const config = vscode.workspace.getConfiguration('orca');
  const binaryPath = config.get<string>('binaryPath', '/opt/orca/orca');
  const saveToFile = config.get<boolean>('saveOutputToFile', true);

  // NEW: Initialize output file writer
  this.outputWriter = new OutputFileWriter(inputFilePath, saveToFile);
  try {
    await this.outputWriter.initialize();
  } catch (error) {
    vscode.window.showWarningMessage(
      `Failed to create output file: ${error}. Output will only appear in Output panel.`
    );
    this.outputWriter = null; // Degrade gracefully
  }

  // ... existing spawn code ...
```

**Modify stdout handler** (around line 100-110):
```typescript
this.currentProcess.stdout?.on('data', (data: Buffer) => {
  const output = data.toString();
  this.outputChannel.append(output);
  
  // NEW: Write to file
  if (this.outputWriter) {
    this.outputWriter.write(output);
  }
});

this.currentProcess.stderr?.on('data', (data: Buffer) => {
  const output = data.toString();
  this.outputChannel.append(output);
  
  // NEW: Write to file
  if (this.outputWriter) {
    this.outputWriter.write(output);
  }
});
```

**Modify close handler** (around line 120-130):
```typescript
this.currentProcess.on('close', async (code: number) => {
  // NEW: Close output file writer
  if (this.outputWriter) {
    try {
      await this.outputWriter.close();
      const outPath = this.outputWriter.getOutputPath();
      this.outputChannel.appendLine(`\n✅ Output saved to: ${outPath}`);
    } catch (error) {
      console.error('Failed to close output file:', error);
    } finally {
      this.outputWriter = null;
    }
  }

  // ... existing close handling code ...
});
```

#### 4. Update killJob() Method

Ensure output writer is cleaned up on job termination:
```typescript
public killJob(): void {
  if (this.currentProcess) {
    this.currentProcess.kill('SIGTERM');
    
    // NEW: Close output writer on kill
    if (this.outputWriter) {
      this.outputWriter.close().catch((err) => {
        console.error('Error closing output writer on kill:', err);
      });
      this.outputWriter = null;
    }
    
    this.currentProcess = null;
    // ... rest of existing code ...
  }
}
```

---

## Implementation Steps

### Step 1: Add Import and Property (10 min)
1. Add import statement at top of file
2. Add `outputWriter` property to class
3. Compile and verify no errors

### Step 2: Initialize Writer (30 min)
1. Get configuration value
2. Instantiate `OutputFileWriter`
3. Call `initialize()` with error handling
4. Test with breakpoint to verify instantiation

### Step 3: Wire stdout/stderr (30 min)
1. Add `write()` calls in both handlers
2. Test with simple ORCA job
3. Verify `.out` file created and contains content

### Step 4: Handle Cleanup (30 min)
1. Add `close()` call in close event handler
2. Add success message to output channel
3. Add cleanup to `killJob()`
4. Test job completion and termination scenarios

### Step 5: Test Edge Cases (20 min)
1. Test with `saveOutputToFile: false`
2. Test with write permission failure
3. Test with job killed mid-execution
4. Verify output channel always works

---

## Acceptance Criteria

### Functional Requirements
- ✅ `.out` file created for every ORCA job run
- ✅ File contains all stdout and stderr output
- ✅ Output channel still receives all output (existing functionality preserved)
- ✅ Success message shows output file path
- ✅ File properly closed on job completion
- ✅ File closed on job termination (kill)
- ✅ Configuration `orca.saveOutputToFile` respected

### Code Quality
- ✅ No TypeScript compilation errors
- ✅ No ESLint warnings
- ✅ Error handling doesn't crash extension
- ✅ Existing functionality unchanged
- ✅ Code follows project style

### Edge Cases
- ✅ Writer disabled via config → no file created, no errors
- ✅ Writer initialization fails → output channel still works, warning shown
- ✅ Job killed mid-execution → file closed properly
- ✅ Multiple jobs in sequence → each creates separate file

---

## Testing Instructions

### Test Case 1: Basic Integration
1. Open `examples/water_opt.inp`
2. Press F5 to run ORCA job
3. **Expected**: 
   - Output channel shows all output
   - `examples/water_opt.out` file created
   - Success message shows file path
   - File contains same content as output channel

### Test Case 2: Disabled Writing
1. Open Settings (JSON)
2. Add: `"orca.saveOutputToFile": false`
3. Run ORCA job
4. **Expected**:
   - No `.out` file created
   - Output channel still works normally
   - No errors or warnings

### Test Case 3: Job Termination
1. Run a long ORCA job
2. Use `vs-orca.killJob` command (or Ctrl+C)
3. **Expected**:
   - `.out` file exists with partial output
   - File is properly closed (can be opened)
   - No error messages

### Test Case 4: Failed Job
1. Run ORCA job that fails (SCF not converged)
2. **Expected**:
   - `.out` file contains all output including errors
   - File properly closed
   - Error output visible in both file and channel

### Test Case 5: Permission Error Simulation
1. Create a read-only directory
2. Place `.inp` file in that directory
3. Run job
4. **Expected**:
   - Warning message shown
   - Output channel still works
   - Extension doesn't crash

---

## Integration Points

### With OutputFileWriter (TASK-003-001)
- Uses all public methods: `initialize()`, `write()`, `close()`, `getOutputPath()`

### With Configuration (TASK-003-003)
- Reads `orca.saveOutputToFile` setting
- Future: Will also read `orca.outputFileTimestamp`

### With Dashboard (TASK-003-017)
- Dashboard will read the `.out` files created by this integration
- File path available via `getOutputPath()`

---

## Performance Considerations

- **Overhead**: Minimal (<1% CPU); streaming writes are non-blocking
- **Memory**: No additional memory usage (both channel and file use same data)
- **Disk I/O**: Sequential writes are efficient; no random access

---

## Backwards Compatibility

- **Existing Users**: Feature enabled by default; users can disable if desired
- **Old Workflows**: Output channel continues to work exactly as before
- **No Breaking Changes**: All existing commands and behaviors preserved

---

## Documentation Requirements

### Code Comments
- Add comment explaining dual output strategy
- Document error degradation behavior

### User-Facing
- Will be documented in user guide (TASK-003-027)
- Setting description added in TASK-003-003

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| File writes slow down ORCA execution | Very Low | Low | Streaming writes are async; benchmark in Phase 5 |
| Error in writer crashes extension | Low | High | Wrapped in try-catch; degrade to channel-only |
| Concurrent jobs overwrite files | Medium | Medium | Each `.inp` has unique `.out`; document this behavior |

---

## Debugging Tips

If integration issues occur:
1. Add `console.log()` statements in stdout handler
2. Check if `this.outputWriter` is null (initialization failed)
3. Verify file created with `ls -la` in output directory
4. Check VS Code Developer Tools console for errors
5. Try with `saveOutputToFile: false` to isolate issue

---

## Follow-up Tasks

After this task:
- TASK-003-004: Add real-time progress (optional enhancement)
- TASK-003-005: Write unit tests for integration
- TASK-003-027: Document in user guide

---

## Completion Checklist

- [ ] Import statement added
- [ ] Class property added
- [ ] Writer initialization implemented
- [ ] stdout/stderr wired to writer
- [ ] Close handler updated
- [ ] killJob() updated
- [ ] All test cases passed
- [ ] No compilation/lint errors
- [ ] Code reviewed

---

**Notes**:
- Keep changes minimal and focused
- Preserve all existing functionality
- Error handling is critical for user experience
