# TASK-003-017: Create DashboardPanel Webview Component

**Phase**: Phase 4 - Results Dashboard  
**Priority**: P0 (Must-Have)  
**Estimated Effort**: 4 hours  
**Assigned To**: TBD  
**Status**: Not Started

---

## Overview

Create the core webview component infrastructure for the ORCA results dashboard. This provides a visual interface for displaying parsed output data, including energies, convergence status, SCF cycles, geometry steps, and frequencies.

---

## Dependencies

**Blocked By**: 
- TASK-003-011 (ParsedResults interface must be defined)
- TASK-003-012 to 003-016 (Parser must extract all data)

**Blocks**:
- TASK-003-018 (Dashboard UI design relies on this infrastructure)
- TASK-003-021 (Show dashboard command)

---

## Objectives

1. Create `DashboardPanel` class managing webview lifecycle
2. Implement singleton pattern for panel management
3. Set up message passing between extension and webview
4. Integrate with `OutputParser` for data retrieval
5. Handle panel disposal and resource cleanup

---

## Technical Specifications

### File Location
Create new file: `src/dashboard/dashboardPanel.ts`

### Class Architecture

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { OutputParser, ParsedResults } from '../outputParser';

/**
 * Manages the ORCA results dashboard webview panel
 */
export class DashboardPanel {
  /**
   * Singleton instance (only one dashboard open at a time)
   */
  private static currentPanel: DashboardPanel | undefined;

  /**
   * VS Code webview panel
   */
  private readonly panel: vscode.WebviewPanel;

  /**
   * Output parser instance
   */
  private readonly parser: OutputParser;

  /**
   * Currently displayed output file path
   */
  private currentOutputFile: string | undefined;

  /**
   * File system watcher for live updates
   */
  private fileWatcher: vscode.FileSystemWatcher | undefined;

  /**
   * Disposables for cleanup
   */
  private disposables: vscode.Disposable[] = [];

  /**
   * Create or show the dashboard panel
   * @param extensionUri - Extension root URI for resource loading
   * @param outputFilePath - Path to .out file to display
   * @returns Dashboard panel instance
   */
  public static createOrShow(
    extensionUri: vscode.Uri,
    outputFilePath: string
  ): DashboardPanel {
    const column = vscode.ViewColumn.Beside;

    // If panel exists, reveal and update
    if (DashboardPanel.currentPanel) {
      DashboardPanel.currentPanel.panel.reveal(column);
      DashboardPanel.currentPanel.updateResults(outputFilePath);
      return DashboardPanel.currentPanel;
    }

    // Create new panel
    const panel = vscode.window.createWebviewPanel(
      'orcaResultsDashboard',
      'ORCA Results',
      column,
      {
        enableScripts: true,
        localResourceRoots: [
          vscode.Uri.joinPath(extensionUri, 'dist'),
          vscode.Uri.joinPath(extensionUri, 'media')
        ],
        retainContextWhenHidden: true // Keep state when hidden
      }
    );

    DashboardPanel.currentPanel = new DashboardPanel(
      panel,
      extensionUri,
      outputFilePath
    );

    return DashboardPanel.currentPanel;
  }

  /**
   * Private constructor (use createOrShow)
   */
  private constructor(
    panel: vscode.WebviewPanel,
    extensionUri: vscode.Uri,
    outputFilePath: string
  ) {
    this.panel = panel;
    this.parser = new OutputParser();
    this.currentOutputFile = outputFilePath;

    // Set up panel
    this.panel.webview.html = this.getWebviewContent(extensionUri);
    
    // Handle panel disposal
    this.panel.onDidDispose(() => this.dispose(), null, this.disposables);

    // Handle messages from webview
    this.panel.webview.onDidReceiveMessage(
      message => this.handleMessage(message),
      null,
      this.disposables
    );

    // Initial data load
    this.updateResults(outputFilePath);

    // Set up file watcher for live updates
    this.setupFileWatcher(outputFilePath);
  }

  /**
   * Update dashboard with new output file
   */
  public async updateResults(outputFilePath: string): Promise<void> {
    try {
      this.currentOutputFile = outputFilePath;

      // Update panel title
      const fileName = path.basename(outputFilePath);
      this.panel.title = `ORCA Results - ${fileName}`;

      // Parse output file
      const results = await this.parser.parseOutputFile(outputFilePath);

      // Send results to webview
      this.panel.webview.postMessage({
        type: 'update',
        data: results
      });

      // Update file watcher
      if (this.fileWatcher) {
        this.fileWatcher.dispose();
      }
      this.setupFileWatcher(outputFilePath);

    } catch (error) {
      vscode.window.showErrorMessage(
        `Failed to parse ORCA output: ${error}`
      );
      
      // Send error to webview
      this.panel.webview.postMessage({
        type: 'error',
        message: `Failed to load output file: ${error}`
      });
    }
  }

  /**
   * Set up file system watcher for live updates
   */
  private setupFileWatcher(filePath: string): void {
    const fileUri = vscode.Uri.file(filePath);
    
    this.fileWatcher = vscode.workspace.createFileSystemWatcher(
      filePath,
      false, // ignoreCreateEvents
      false, // ignoreChangeEvents
      false  // ignoreDeleteEvents
    );

    // Debounce updates (500ms)
    let updateTimeout: NodeJS.Timeout | undefined;

    this.fileWatcher.onDidChange(() => {
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }
      
      updateTimeout = setTimeout(() => {
        this.updateResults(filePath);
      }, 500);
    });

    this.disposables.push(this.fileWatcher);
  }

  /**
   * Handle messages from webview
   */
  private async handleMessage(message: any): Promise<void> {
    switch (message.type) {
      case 'export':
        await this.exportResults();
        break;
      
      case 'refresh':
        if (this.currentOutputFile) {
          await this.updateResults(this.currentOutputFile);
        }
        break;
      
      case 'openOutputFile':
        if (this.currentOutputFile) {
          const doc = await vscode.workspace.openTextDocument(
            this.currentOutputFile
          );
          await vscode.window.showTextDocument(doc);
        }
        break;

      case 'ready':
        // Webview is ready, send initial data
        if (this.currentOutputFile) {
          await this.updateResults(this.currentOutputFile);
        }
        break;
    }
  }

  /**
   * Export results to clipboard as JSON
   */
  private async exportResults(): Promise<void> {
    if (!this.currentOutputFile) {
      return;
    }

    try {
      const results = await this.parser.parseOutputFile(this.currentOutputFile);
      const json = JSON.stringify(results, null, 2);
      
      await vscode.env.clipboard.writeText(json);
      
      vscode.window.showInformationMessage(
        'Results exported to clipboard as JSON'
      );
    } catch (error) {
      vscode.window.showErrorMessage(
        `Failed to export results: ${error}`
      );
    }
  }

  /**
   * Get webview HTML content
   * (Placeholder - implemented in TASK-003-018)
   */
  private getWebviewContent(extensionUri: vscode.Uri): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ORCA Results</title>
</head>
<body>
  <h1>ORCA Results Dashboard</h1>
  <div id="app">Loading...</div>
  <script>
    const vscode = acquireVsCodeApi();
    
    // Notify extension that webview is ready
    vscode.postMessage({ type: 'ready' });
    
    // Handle messages from extension
    window.addEventListener('message', event => {
      const message = event.data;
      if (message.type === 'update') {
        document.getElementById('app').textContent = 
          JSON.stringify(message.data, null, 2);
      } else if (message.type === 'error') {
        document.getElementById('app').innerHTML = 
          '<p style="color: red;">Error: ' + message.message + '</p>';
      }
    });
  </script>
</body>
</html>`;
  }

  /**
   * Clean up resources
   */
  public dispose(): void {
    DashboardPanel.currentPanel = undefined;

    this.panel.dispose();

    while (this.disposables.length) {
      const disposable = this.disposables.pop();
      if (disposable) {
        disposable.dispose();
      }
    }
  }
}
```

---

## Implementation Steps

### Step 1: Create File Structure (15 min)
1. Create `src/dashboard/` directory
2. Create `dashboardPanel.ts`
3. Add necessary imports

### Step 2: Implement Singleton Pattern (30 min)
1. Add static `currentPanel` property
2. Implement `createOrShow()` method
3. Handle panel reuse vs. creation

### Step 3: Implement Constructor (45 min)
1. Initialize panel with configuration
2. Set up event handlers
3. Configure webview options
4. Load initial HTML content

### Step 4: Implement Update Logic (45 min)
1. Create `updateResults()` method
2. Integrate with `OutputParser`
3. Send data via `postMessage`
4. Handle errors gracefully

### Step 5: Implement File Watcher (45 min)
1. Create `setupFileWatcher()` method
2. Add debouncing logic (500ms)
3. Handle file changes, creation, deletion
4. Clean up on disposal

### Step 6: Implement Message Handling (45 min)
1. Create `handleMessage()` method
2. Handle export, refresh, open file actions
3. Add 'ready' event handling

### Step 7: Implement Cleanup (15 min)
1. Create `dispose()` method
2. Clean up watchers, disposables
3. Reset singleton instance

---

## Acceptance Criteria

### Functional Requirements
- ✅ Panel opens in beside column
- ✅ Singleton pattern: only one panel at a time
- ✅ Panel updates when output file changes
- ✅ Panel displays parsed results
- ✅ Export to clipboard works
- ✅ Refresh button works
- ✅ Open output file button works
- ✅ Panel disposes cleanly

### Code Quality
- ✅ TypeScript compiles with no errors
- ✅ All methods have JSDoc comments
- ✅ Error handling for all operations
- ✅ Resource cleanup on disposal
- ✅ No memory leaks

### Performance
- ✅ File watcher debounced (no excessive updates)
- ✅ Panel retains context when hidden
- ✅ Updates complete in <500ms

---

## Testing Instructions

### Test Case 1: Basic Panel Creation
```typescript
const panel = DashboardPanel.createOrShow(
  extensionUri,
  '/path/to/output.out'
);
// Expected: Panel opens, displays results
```

### Test Case 2: Singleton Behavior
```typescript
const panel1 = DashboardPanel.createOrShow(uri, 'file1.out');
const panel2 = DashboardPanel.createOrShow(uri, 'file2.out');
console.assert(panel1 === panel2, 'Same instance returned');
// Expected: Panel updates to show file2.out
```

### Test Case 3: Live Updates
1. Open dashboard for a file
2. Modify the .out file externally
3. Wait 500ms
4. Expected: Dashboard updates automatically

### Test Case 4: Export
1. Open dashboard
2. Click export button (or send message)
3. Expected: JSON in clipboard

---

## Integration Points

### With OutputParser (TASK-003-011)
- Uses `parseOutputFile()` method
- Consumes `ParsedResults` interface

### With Dashboard UI (TASK-003-018)
- Provides HTML content placeholder
- Sends data via postMessage

### With Commands (TASK-003-021)
- Exposed via `createOrShow()` public method

---

## Security Considerations

- **Content Security Policy**: Will be added in TASK-003-018
- **Resource Loading**: Only local resources from extension
- **Message Validation**: Validate message types from webview

---

## Completion Checklist

- [ ] File created with class structure
- [ ] Singleton pattern implemented
- [ ] Constructor and initialization work
- [ ] Update logic implemented
- [ ] File watcher working with debounce
- [ ] Message handling complete
- [ ] Disposal and cleanup working
- [ ] All test cases pass
- [ ] Ready for TASK-003-018

---

**Notes**:
- HTML content is placeholder; full UI in TASK-003-018
- Focus on infrastructure and message passing
- Ensure clean resource management
