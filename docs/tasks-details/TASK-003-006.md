# TASK-003-006: Create ORCA Output TextMate Grammar

**Phase**: Phase 2 - Syntax Highlighting & Navigation  
**Priority**: P0 (Must-Have)  
**Estimated Effort**: 4 hours  
**Assigned To**: TBD  
**Status**: Not Started

---

## Overview

Create a comprehensive TextMate grammar for ORCA output files (`.out`) that provides syntax highlighting with color-coded sections, numerical values, warnings, and errors. This enhances readability of large output files and helps users quickly identify important information.

---

## Dependencies

**Blocked By**: 
- TASK-003-001 (Output files must exist to test grammar)

**Blocks**:
- TASK-003-007 (File association registration)
- TASK-003-010 (Navigation testing relies on visual feedback)

---

## Objectives

1. Create TextMate grammar JSON file for `.out` files
2. Define color scopes for sections, energies, warnings, errors
3. Support ORCA-specific output patterns and keywords
4. Test with diverse output files
5. Ensure consistent theme compatibility

---

## Technical Specifications

### File Location
Create new file: `syntaxes/orca.out.tmLanguage.json`

### Grammar Structure

```json
{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "ORCA Output",
  "scopeName": "text.orca-output",
  "patterns": [
    { "include": "#section-headers" },
    { "include": "#energies" },
    { "include": "#convergence-markers" },
    { "include": "#warnings" },
    { "include": "#errors" },
    { "include": "#numbers" },
    { "include": "#coordinates" },
    { "include": "#frequency-tables" },
    { "include": "#timings" }
  ],
  "repository": {
    "section-headers": {
      "patterns": [
        {
          "name": "entity.name.section.orca-output",
          "match": "^-{50,}$\\n([A-Z][A-Z\\s]+)\\n-{50,}$",
          "captures": {
            "1": { "name": "markup.heading.section.orca-output" }
          }
        },
        {
          "name": "markup.heading.orca-output",
          "match": "^={50,}$"
        }
      ]
    },
    "energies": {
      "patterns": [
        {
          "name": "constant.numeric.energy.orca-output",
          "match": "(FINAL SINGLE POINT ENERGY|TOTAL ENERGY|Total Energy)\\s+([-+]?\\d+\\.\\d+)",
          "captures": {
            "1": { "name": "keyword.energy-label.orca-output" },
            "2": { "name": "constant.numeric.float.orca-output" }
          }
        },
        {
          "name": "constant.numeric.energy.orca-output",
          "match": "(E\\(\\w+\\)|Energy)\\s*[:=]\\s*([-+]?\\d+\\.\\d+)"
        }
      ]
    },
    "convergence-markers": {
      "patterns": [
        {
          "name": "markup.bold.success.orca-output",
          "match": "\\*{3}\\s*HURRAY\\s*\\*{3}|CONVERGENCE ACHIEVED|OPTIMIZATION RUN DONE"
        },
        {
          "name": "invalid.illegal.failed.orca-output",
          "match": "SCF NOT CONVERGED|OPTIMIZATION NOT CONVERGED|\\*{3}ABORTING THE RUN\\*{3}"
        }
      ]
    },
    "warnings": {
      "patterns": [
        {
          "name": "invalid.deprecated.warning.orca-output",
          "match": "^\\s*(WARNING|Warning|ATTENTION):.*$"
        },
        {
          "name": "markup.italic.info.orca-output",
          "match": "^\\s*(NOTE|Note|INFO):.*$"
        }
      ]
    },
    "errors": {
      "patterns": [
        {
          "name": "invalid.illegal.error.orca-output",
          "match": "^\\s*(ERROR|Error|FATAL):.*$"
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.float.orca-output",
          "match": "\\b[-+]?\\d+\\.\\d+([eE][-+]?\\d+)?\\b"
        },
        {
          "name": "constant.numeric.integer.orca-output",
          "match": "\\b\\d+\\b"
        }
      ]
    },
    "coordinates": {
      "patterns": [
        {
          "name": "entity.name.tag.coordinate.orca-output",
          "match": "^\\s*([A-Z][a-z]?)\\s+([-+]?\\d+\\.\\d+)\\s+([-+]?\\d+\\.\\d+)\\s+([-+]?\\d+\\.\\d+)",
          "captures": {
            "1": { "name": "entity.name.type.atom.orca-output" },
            "2": { "name": "constant.numeric.coordinate.orca-output" },
            "3": { "name": "constant.numeric.coordinate.orca-output" },
            "4": { "name": "constant.numeric.coordinate.orca-output" }
          }
        }
      ]
    },
    "frequency-tables": {
      "patterns": [
        {
          "name": "keyword.frequency.orca-output",
          "match": "^\\s*(Mode|Frequency|IR Intensity|Raman Activity)\\b"
        },
        {
          "name": "invalid.deprecated.imaginary.orca-output",
          "match": "\\*{3}imaginary mode\\*{3}"
        }
      ]
    },
    "timings": {
      "patterns": [
        {
          "name": "comment.timing.orca-output",
          "match": "^\\s*Timings for.*$"
        },
        {
          "name": "keyword.timing-label.orca-output",
          "match": "(Total time|Wall time|CPU time)\\s*[:=]"
        }
      ]
    }
  }
}
```

### Color Scope Mapping

| Element | Scope | Typical Theme Color |
|---------|-------|---------------------|
| Section headers | `entity.name.section` | Green/Cyan (bold) |
| Energy values | `constant.numeric.energy` | Cyan/Blue |
| Success markers | `markup.bold.success` | Green (bold) |
| Failures | `invalid.illegal.failed` | Red (bold) |
| Warnings | `invalid.deprecated.warning` | Yellow/Orange |
| Errors | `invalid.illegal.error` | Red |
| Numbers | `constant.numeric.float` | Light blue |
| Atom symbols | `entity.name.type.atom` | Magenta |
| Imaginary modes | `invalid.deprecated.imaginary` | Orange |

---

## Implementation Steps

### Step 1: Create Grammar File (30 min)
1. Create `syntaxes/orca.out.tmLanguage.json`
2. Add JSON schema reference
3. Set up basic structure with name and scopeName

### Step 2: Implement Section Headers (45 min)
1. Add pattern for dashed lines (`---`)
2. Add pattern for equals lines (`===`)
3. Capture section titles (uppercase text between lines)
4. Test with example output sections

### Step 3: Implement Energy Patterns (45 min)
1. Add pattern for "FINAL SINGLE POINT ENERGY"
2. Add patterns for other energy labels
3. Separate label and value captures
4. Test with various energy formats

### Step 4: Implement Convergence Markers (30 min)
1. Add success markers (HURRAY, etc.)
2. Add failure markers (SCF NOT CONVERGED, etc.)
3. Test with converged and failed outputs

### Step 5: Implement Warnings and Errors (30 min)
1. Add WARNING/ERROR patterns
2. Add NOTE/INFO patterns
3. Match full line for context
4. Test with outputs containing warnings

### Step 6: Implement Number Highlighting (20 min)
1. Add float pattern with scientific notation
2. Add integer pattern
3. Ensure non-greedy matching

### Step 7: Implement Specialized Patterns (40 min)
1. Add coordinate line pattern (atom + xyz)
2. Add frequency table headers
3. Add imaginary mode detection
4. Add timing information

### Step 8: Test with Examples (30 min)
1. Open `examples/water_opt.out` (create test file)
2. Verify all patterns work
3. Test with different VS Code themes
4. Fix any mis-matched patterns

---

## Acceptance Criteria

### Functional Requirements
- ✅ Section headers highlighted in distinct color
- ✅ Energy values highlighted (label and number)
- ✅ "HURRAY" and convergence success in green/bold
- ✅ "SCF NOT CONVERGED" in red/bold
- ✅ Warnings in yellow/orange
- ✅ Errors in red
- ✅ Numbers consistently highlighted
- ✅ Atom coordinates recognized
- ✅ Imaginary frequency modes highlighted

### Code Quality
- ✅ Valid JSON (no syntax errors)
- ✅ Follows TextMate grammar conventions
- ✅ Scope names follow standard conventions
- ✅ Patterns are specific (no false positives)
- ✅ Regular expressions tested and optimized

### Theme Compatibility
- ✅ Works with Dark+ (default dark)
- ✅ Works with Light+ (default light)
- ✅ Works with popular themes (Monokai, Solarized)
- ✅ Degrades gracefully with minimal themes

---

## Testing Instructions

### Test File Creation
Create `src/test/fixtures/outputs/test_syntax.out`:
```
--------------------------------------------------------------------------------
                           INPUT FILE
--------------------------------------------------------------------------------
! B3LYP def2-SVP Opt

--------------------------------------------------------------------------------
                       SCF ITERATIONS
--------------------------------------------------------------------------------
ITER       Energy         Delta-E        Max-DP      RMS-DP
   0    -76.123456789    0.000000       0.123456    0.012345
   1    -76.234567890   -0.111111       0.023456    0.002345
...

*** HURRAY ***
SCF CONVERGED AFTER 12 ITERATIONS

FINAL SINGLE POINT ENERGY      -76.382934718263

WARNING: Small interatomic distance detected

--------------------------------------------------------------------------------
                    VIBRATIONAL FREQUENCIES
--------------------------------------------------------------------------------
Mode    Frequency       IR Intensity
  0     3756.23            45.2
  1     3652.11            78.3
  2     1595.44           156.7

***imaginary mode***

ERROR: SCF did not converge
```

### Manual Testing Steps
1. Open test file in VS Code
2. Verify colors for each element type
3. Switch themes and verify compatibility
4. Check for false positives (normal text highlighted incorrectly)
5. Test with real ORCA outputs

### Automated Validation
```bash
# Validate JSON syntax
npx jsonlint syntaxes/orca.out.tmLanguage.json

# Test with VS Code
code --extensionDevelopmentPath=. examples/water_opt.out
```

---

## Integration Points

### With File Association (TASK-003-007)
- Grammar must be registered in `package.json` to activate

### With Document Symbol Provider (TASK-003-008)
- Section header patterns should align with symbol detection

### With Example Files (Phase 5)
- Real ORCA outputs will test grammar comprehensiveness

---

## Performance Considerations

- **Regex Efficiency**: Use specific patterns, avoid backtracking
- **Large Files**: Grammar should work with 10MB+ files without lag
- **Incremental Updates**: VS Code tokenizes incrementally; patterns should support this

---

## Edge Cases

- **Mixed Case**: ORCA sometimes varies capitalization
- **Localization**: Some messages may vary by ORCA version
- **Long Lines**: Coordinate tables can have many columns
- **Unicode**: Some special characters in section dividers

---

## References

- **TextMate Grammar Guide**: https://macromates.com/manual/en/language_grammars
- **VS Code Syntax Highlighting**: https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide
- **Scope Naming**: https://www.sublimetext.com/docs/scope_naming.html
- **ORCA Manual**: https://orcaforum.kofo.mpg.de/ (output format examples)

---

## Common Patterns in ORCA Output

### Section Headers
```
--------------------------------------------------------------------------------
                           SECTION NAME
--------------------------------------------------------------------------------
```

### Energy Lines
```
FINAL SINGLE POINT ENERGY      -76.382934718263
Total Energy       :      -76.38293472 Eh
```

### Convergence
```
*** HURRAY ***
SCF NOT CONVERGED AFTER 250 ITERATIONS
```

### Geometry
```
CARTESIAN COORDINATES (ANGSTROEM)
O      0.000000    0.000000    0.119262
H      0.000000    0.763239   -0.477049
H      0.000000   -0.763239   -0.477049
```

---

## Completion Checklist

- [ ] Grammar file created
- [ ] All pattern categories implemented
- [ ] Test file created with diverse patterns
- [ ] Manual testing with multiple themes
- [ ] JSON syntax validated
- [ ] Real ORCA output tested
- [ ] No performance issues
- [ ] Ready for registration (TASK-003-007)

---

**Notes**:
- Start with core patterns (headers, energies, convergence)
- Add specialized patterns incrementally
- Test frequently with real outputs
- Balance specificity with flexibility (ORCA format varies slightly by version)
