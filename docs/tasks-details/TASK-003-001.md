# TASK-003-001: Create OutputFileWriter Class

**Phase**: Phase 1 - Output File Persistence  
**Priority**: P0 (Blocker)  
**Estimated Effort**: 3 hours  
**Assigned To**: TBD  
**Status**: Not Started

---

## Overview

Create a dedicated `OutputFileWriter` class that handles streaming ORCA execution output to `.out` files. This class provides the foundation for automatic output persistence with real-time updates during job execution.

---

## Dependencies

**Blocked By**: None  
**Blocks**:
- TASK-003-002 (Integration with OrcaRunner)
- TASK-003-004 (Real-time file writing)
- TASK-003-005 (Unit tests)

---

## Objectives

1. Create reusable file writing class with streaming capabilities
2. Handle file creation, writing, and proper cleanup
3. Implement error handling for file system operations
4. Support configuration-driven behavior
5. Provide clean API for integration with OrcaRunner

---

## Technical Specifications

### File Location
Create new file: `src/outputWriter.ts`

### Class Interface

```typescript
import * as fs from 'fs';
import * as path from 'path';

/**
 * Handles streaming ORCA execution output to .out files
 */
export class OutputFileWriter {
  private fileStream: fs.WriteStream | null = null;
  private outputPath: string;
  private isEnabled: boolean;

  /**
   * @param inputFilePath - Absolute path to the .inp file
   * @param enabled - Whether file writing is enabled (from config)
   */
  constructor(inputFilePath: string, enabled: boolean = true) {
    this.outputPath = inputFilePath.replace(/\.inp$/i, '.out');
    this.isEnabled = enabled;
  }

  /**
   * Initialize the output file stream
   * @throws Error if file creation fails
   */
  public async initialize(): Promise<void> {
    if (!this.isEnabled) {
      return;
    }

    try {
      // Create directory if it doesn't exist
      const dir = path.dirname(this.outputPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // Create write stream with 'w' flag (truncate if exists)
      this.fileStream = fs.createWriteStream(this.outputPath, {
        flags: 'w',
        encoding: 'utf8',
        autoClose: true
      });

      // Handle stream errors
      this.fileStream.on('error', (err) => {
        console.error(`OutputFileWriter: Error writing to ${this.outputPath}`, err);
        this.fileStream = null;
      });

    } catch (error) {
      console.error(`OutputFileWriter: Failed to initialize ${this.outputPath}`, error);
      throw error;
    }
  }

  /**
   * Write data to the output file
   * @param data - Text data to write (stdout or stderr)
   */
  public write(data: string): void {
    if (!this.isEnabled || !this.fileStream) {
      return;
    }

    this.fileStream.write(data);
  }

  /**
   * Close the file stream and finalize the output file
   */
  public async close(): Promise<void> {
    if (!this.fileStream) {
      return;
    }

    return new Promise((resolve, reject) => {
      this.fileStream!.end((err?: Error) => {
        if (err) {
          console.error(`OutputFileWriter: Error closing ${this.outputPath}`, err);
          reject(err);
        } else {
          this.fileStream = null;
          resolve();
        }
      });
    });
  }

  /**
   * Get the output file path
   */
  public getOutputPath(): string {
    return this.outputPath;
  }

  /**
   * Check if file writing is enabled
   */
  public isWritingEnabled(): boolean {
    return this.isEnabled && this.fileStream !== null;
  }
}
```

### Error Handling Strategy

1. **Directory Creation**: Create parent directories if they don't exist
2. **File Overwrite**: Always truncate existing `.out` files (warn in future tasks)
3. **Stream Errors**: Log errors but don't crash; degrade gracefully to output channel only
4. **Cleanup**: Ensure stream is properly closed even on job failure

### Path Handling Rules

- Input: `/path/to/water_opt.inp` → Output: `/path/to/water_opt.out`
- Handle case-insensitive extensions: `.INP` → `.out`
- If input doesn't end with `.inp`, append `.out` (edge case)

---

## Implementation Steps

### Step 1: Create File Structure (15 min)
1. Create `src/outputWriter.ts`
2. Import required Node.js modules (`fs`, `path`)
3. Add copyright header consistent with project

### Step 2: Implement Constructor (30 min)
1. Define class properties
2. Implement path transformation logic
3. Handle configuration parameter
4. Add JSDoc comments

### Step 3: Implement initialize() Method (45 min)
1. Check if writing is enabled
2. Create parent directory if needed
3. Create write stream with proper options
4. Set up error event handler
5. Handle initialization errors

### Step 4: Implement write() Method (30 min)
1. Guard clauses for disabled/uninitialized state
2. Stream write call
3. No explicit error handling (stream handles it)

### Step 5: Implement close() Method (45 min)
1. Convert stream.end() to Promise
2. Handle close errors
3. Null out stream reference
4. Log closure (optional debug)

### Step 6: Add Utility Methods (15 min)
1. `getOutputPath()` getter
2. `isWritingEnabled()` status check
3. JSDoc documentation

---

## Acceptance Criteria

### Functional Requirements
- ✅ Class instantiates with input file path
- ✅ `initialize()` creates `.out` file in same directory as `.inp`
- ✅ `write()` streams data to file in real-time
- ✅ `close()` properly finalizes file
- ✅ Disabled state skips all file operations
- ✅ Parent directories created automatically

### Code Quality
- ✅ TypeScript compiles with no errors
- ✅ All methods have JSDoc comments
- ✅ Error handling for all file operations
- ✅ Follows existing project coding style
- ✅ No linting errors (`npm run lint`)

### Edge Cases Handled
- ✅ Input file path with uppercase `.INP` extension
- ✅ Output file already exists (truncates)
- ✅ Directory doesn't exist (creates)
- ✅ File write permission denied (logs error, degrades gracefully)
- ✅ Stream closed before initialization (no-op)

---

## Testing Instructions

### Manual Testing (Pre-Unit Test)

1. **Basic Functionality**:
```typescript
import { OutputFileWriter } from './outputWriter';

const writer = new OutputFileWriter('/tmp/test.inp', true);
await writer.initialize();
writer.write('Test output line 1\n');
writer.write('Test output line 2\n');
await writer.close();

// Verify /tmp/test.out contains both lines
```

2. **Disabled State**:
```typescript
const writer = new OutputFileWriter('/tmp/test.inp', false);
await writer.initialize(); // Should do nothing
writer.write('This should not be written');
await writer.close();

// Verify /tmp/test.out does not exist
```

3. **Error Handling**:
```typescript
const writer = new OutputFileWriter('/root/nopermission.inp', true);
try {
  await writer.initialize(); // Should throw or log error
} catch (err) {
  console.log('Expected error:', err);
}
```

### Unit Test Checklist
- [ ] File created with correct name
- [ ] Content written correctly
- [ ] File closed properly
- [ ] Disabled state prevents writes
- [ ] Error handling works
- [ ] Path transformation correct
- [ ] Multiple write calls succeed

---

## Integration Points

### With OrcaRunner (TASK-003-002)
```typescript
// In OrcaRunner.runOrcaJob()
const writer = new OutputFileWriter(inputFilePath, config.get('orca.saveOutputToFile'));
await writer.initialize();

process.stdout.on('data', (data) => {
  writer.write(data.toString());
  this.outputChannel.append(data.toString());
});

// On completion
await writer.close();
```

---

## Performance Considerations

- **Streaming**: Uses `fs.WriteStream` to avoid buffering entire output in memory
- **No Blocking**: Write calls are non-blocking (async I/O)
- **Buffer Size**: Default Node.js buffer size (16KB) is appropriate
- **Memory Usage**: O(1) regardless of output file size

---

## Security Considerations

- **Path Validation**: Future task will add validation to prevent directory traversal
- **File Overwrite**: Current implementation silently overwrites; warning in UI in future task
- **Permissions**: Inherits permissions from parent directory

---

## Documentation Requirements

### Code Comments
- JSDoc for class and all public methods
- Inline comments for error handling logic
- Example usage in class-level JSDoc

### Future Documentation Updates
- Add to developer guide in TASK-003-028
- Reference in user guide (TASK-003-027)

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| File write fails mid-execution | Low | Medium | Log error, continue writing to output channel |
| Large outputs slow down stream | Very Low | Low | Node.js streams are efficient; benchmark in TASK-003-025 |
| Concurrent writes to same file | Very Low | High | ORCA shouldn't run multiple times on same file; add lock in future |

---

## References

- Node.js fs.WriteStream: https://nodejs.org/api/fs.html#class-fswritestream
- VS Code File System: https://code.visualstudio.com/api/references/vscode-api#FileSystem
- Project file structure: `src/orcaRunner.ts` (integration reference)

---

## Completion Checklist

- [ ] File `src/outputWriter.ts` created
- [ ] All methods implemented
- [ ] TypeScript compiles successfully
- [ ] No ESLint errors
- [ ] Manual testing completed
- [ ] Code reviewed (self-review checklist)
- [ ] Ready for integration (TASK-003-002)

---

**Notes**:
- This is a foundational task; thorough implementation will make integration easier
- Focus on clean API design for testability
- Error handling should be defensive but not disruptive to main execution flow
