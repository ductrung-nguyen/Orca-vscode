# TASK-003-011: Extend OutputParser Interface

**Phase**: Phase 3 - Enhanced Parsing  
**Priority**: P0 (Blocker)  
**Estimated Effort**: 2 hours  
**Assigned To**: TBD  
**Status**: Not Started

---

## Overview

Define a comprehensive `ParsedResults` interface and extend the existing output parser to extract detailed information from ORCA output files. This provides the data foundation for the results dashboard and future analysis features.

---

## Dependencies

**Blocked By**: 
- TASK-003-001 (Output files must exist)

**Blocks**:
- TASK-003-012 (SCF cycle counter)
- TASK-003-013 (Geometry step extractor)
- TASK-003-014 (Frequency parser)
- TASK-003-015 (Warning/error collector)
- TASK-003-017 (Dashboard needs parsed data)

---

## Objectives

1. Define comprehensive `ParsedResults` TypeScript interface
2. Extend existing parser with new extraction methods
3. Create modular parsing architecture for extensibility
4. Ensure backward compatibility with existing parsing
5. Add error handling for malformed outputs

---

## Technical Specifications

### File Location
Modify existing file: `src/orcaRunner.ts` (or create `src/outputParser.ts` if refactoring)

### Interface Definition

```typescript
/**
 * Frequency data entry
 */
export interface FrequencyData {
  mode: number;
  frequency: number; // cm^-1
  irIntensity?: number;
  ramanActivity?: number;
  isImaginary: boolean;
}

/**
 * SCF iteration data
 */
export interface SCFIteration {
  iter: number;
  energy: number;
  deltaE: number;
  maxDP?: number;
  rmsDP?: number;
}

/**
 * Geometry optimization step
 */
export interface GeometryStep {
  step: number;
  energy: number;
  maxForce?: number;
  rmsForce?: number;
  maxStep?: number;
  rmsStep?: number;
}

/**
 * Warning or error message
 */
export interface DiagnosticMessage {
  type: 'warning' | 'error' | 'note';
  message: string;
  lineNumber?: number; // Line in output file
}

/**
 * Complete parsed results from ORCA output
 */
export interface ParsedResults {
  // Job identification
  inputFileName?: string;
  orcaVersion?: string;
  
  // Energy results
  finalEnergy?: number; // Hartree
  totalEnergy?: number; // May differ from final in some calculations
  
  // Convergence information
  converged: boolean;
  scfConverged: boolean;
  geometryConverged?: boolean; // For optimization jobs
  
  // SCF details
  scfCycles: number;
  scfIterations?: SCFIteration[]; // Full iteration history
  
  // Geometry optimization (if applicable)
  geometrySteps?: number;
  geometryStepData?: GeometryStep[];
  finalGeometry?: string; // XYZ format coordinates
  
  // Frequency analysis (if applicable)
  frequencies?: FrequencyData[];
  imaginaryModes: number;
  zeroPointEnergy?: number;
  thermalCorrections?: {
    enthalpy?: number;
    entropy?: number;
    gibbsFreeEnergy?: number;
  };
  
  // Execution metadata
  executionTime: string; // Human-readable (e.g., "00:02:34")
  executionTimeSeconds?: number;
  startTime?: Date;
  endTime?: Date;
  
  // Diagnostics
  warnings: DiagnosticMessage[];
  errors: DiagnosticMessage[];
  notes: DiagnosticMessage[];
  
  // Raw data
  rawOutput?: string; // Optional: full output text
  outputFilePath?: string;
}
```

### Parser Class Structure

```typescript
/**
 * Enhanced ORCA output parser
 */
export class OutputParser {
  /**
   * Parse a complete ORCA output file
   * @param filePath - Absolute path to .out file
   * @returns Parsed results object
   */
  public async parseOutputFile(filePath: string): Promise<ParsedResults> {
    const content = await fs.promises.readFile(filePath, 'utf-8');
    return this.parseOutputContent(content, filePath);
  }

  /**
   * Parse ORCA output content (string)
   * @param content - Full output text
   * @param filePath - Optional file path for reference
   * @returns Parsed results object
   */
  public parseOutputContent(content: string, filePath?: string): ParsedResults {
    const results: ParsedResults = {
      converged: false,
      scfConverged: false,
      scfCycles: 0,
      imaginaryModes: 0,
      executionTime: 'Unknown',
      warnings: [],
      errors: [],
      notes: [],
      outputFilePath: filePath
    };

    // Call individual parsing methods
    this.extractBasicInfo(content, results);
    this.extractEnergies(content, results);
    this.extractConvergence(content, results);
    this.extractSCFData(content, results); // TASK-003-012
    this.extractGeometryData(content, results); // TASK-003-013
    this.extractFrequencies(content, results); // TASK-003-014
    this.extractDiagnostics(content, results); // TASK-003-015
    this.extractTimings(content, results);

    return results;
  }

  /**
   * Extract basic job information
   */
  private extractBasicInfo(content: string, results: ParsedResults): void {
    // Extract input file name
    const inputMatch = content.match(/INPUT FILE\s*\n.*\n.*filename\s*\.\.\.\.?\s*(.+\.inp)/i);
    if (inputMatch) {
      results.inputFileName = inputMatch[1].trim();
    }

    // Extract ORCA version
    const versionMatch = content.match(/Program Version (\d+\.\d+\.\d+)/);
    if (versionMatch) {
      results.orcaVersion = versionMatch[1];
    }
  }

  /**
   * Extract energy values (existing + enhanced)
   */
  private extractEnergies(content: string, results: ParsedResults): void {
    // Final single point energy
    const finalEnergyMatch = content.match(/FINAL SINGLE POINT ENERGY\s+([-\d.]+)/);
    if (finalEnergyMatch) {
      results.finalEnergy = parseFloat(finalEnergyMatch[1]);
    }

    // Total energy
    const totalEnergyMatch = content.match(/Total Energy\s*:\s*([-\d.]+)\s*Eh/);
    if (totalEnergyMatch) {
      results.totalEnergy = parseFloat(totalEnergyMatch[1]);
    }

    // Zero-point energy
    const zpeMatch = content.match(/Zero point energy\s*\.\.\.\s*([-\d.]+)\s*Eh/);
    if (zpeMatch) {
      results.zeroPointEnergy = parseFloat(zpeMatch[1]);
    }
  }

  /**
   * Extract convergence status (existing + enhanced)
   */
  private extractConvergence(content: string, results: ParsedResults): void {
    // Overall convergence
    results.converged = content.includes('HURRAY') || 
                       content.includes('CONVERGENCE ACHIEVED');
    
    // SCF convergence
    results.scfConverged = !content.includes('SCF NOT CONVERGED');
    
    // Geometry convergence (for optimization jobs)
    if (content.includes('OPTIMIZATION')) {
      results.geometryConverged = content.includes('THE OPTIMIZATION HAS CONVERGED');
    }
  }

  /**
   * Extract execution timing
   */
  private extractTimings(content: string, results: ParsedResults): void {
    // Wall time
    const wallTimeMatch = content.match(/TOTAL RUN TIME:\s*(\d+)\s*days?\s*(\d+)\s*hours?\s*(\d+)\s*minutes?\s*(\d+)\s*seconds?\s*(\d+)\s*msec/);
    if (wallTimeMatch) {
      const days = parseInt(wallTimeMatch[1]);
      const hours = parseInt(wallTimeMatch[2]);
      const minutes = parseInt(wallTimeMatch[3]);
      const seconds = parseInt(wallTimeMatch[4]);
      
      results.executionTimeSeconds = days * 86400 + hours * 3600 + minutes * 60 + seconds;
      results.executionTime = `${days > 0 ? days + 'd ' : ''}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
  }

  // Placeholder methods (implemented in subsequent tasks)
  private extractSCFData(content: string, results: ParsedResults): void {
    // TASK-003-012
  }

  private extractGeometryData(content: string, results: ParsedResults): void {
    // TASK-003-013
  }

  private extractFrequencies(content: string, results: ParsedResults): void {
    // TASK-003-014
  }

  private extractDiagnostics(content: string, results: ParsedResults): void {
    // TASK-003-015
  }
}
```

---

## Implementation Steps

### Step 1: Define Interfaces (30 min)
1. Create/update type definitions
2. Add JSDoc comments
3. Ensure all fields are properly typed
4. Compile and verify no errors

### Step 2: Create Parser Class Structure (30 min)
1. Define class with public/private methods
2. Create main parsing method
3. Add method stubs for each extraction category
4. Set up error handling framework

### Step 3: Implement Basic Extraction (45 min)
1. Implement `extractBasicInfo()`
2. Enhance `extractEnergies()`
3. Enhance `extractConvergence()`
4. Implement `extractTimings()`

### Step 4: Add File Reading (15 min)
1. Implement `parseOutputFile()` with fs.promises
2. Add error handling for file not found
3. Test with example .out file

---

## Acceptance Criteria

### Functional Requirements
- ✅ `ParsedResults` interface defined with all fields
- ✅ `OutputParser` class created with modular methods
- ✅ Basic extraction methods implemented
- ✅ File reading works correctly
- ✅ Parsing handles missing data gracefully
- ✅ Backward compatible with existing parser usage

### Code Quality
- ✅ All types properly defined
- ✅ JSDoc comments for all public methods
- ✅ Error handling for malformed outputs
- ✅ No TypeScript compilation errors
- ✅ No ESLint warnings

### Data Validation
- ✅ Returns valid results for complete output
- ✅ Returns partial results for incomplete output
- ✅ Handles failed jobs gracefully
- ✅ Numeric conversions are safe (NaN handling)

---

## Testing Instructions

### Test Case 1: Complete Output
```typescript
const parser = new OutputParser();
const results = await parser.parseOutputFile('examples/water_opt.out');

console.assert(results.finalEnergy !== undefined, 'Final energy extracted');
console.assert(results.converged === true, 'Convergence detected');
console.assert(results.scfCycles > 0, 'SCF cycles counted');
```

### Test Case 2: Failed Job
```typescript
const results = await parser.parseOutputFile('test/fixtures/failed_scf.out');

console.assert(results.scfConverged === false, 'SCF failure detected');
console.assert(results.errors.length > 0, 'Errors collected');
```

### Test Case 3: Incomplete Output
```typescript
const results = parser.parseOutputContent('Partial output with no convergence');

console.assert(results.converged === false, 'No false positives');
console.assert(results.finalEnergy === undefined, 'Missing data handled');
```

---

## Integration Points

### With Existing Code
- May refactor existing `parseOrcaOutput()` method
- Maintain backward compatibility for status bar updates

### With Future Tasks
- TASK-003-012 to 003-015 will implement placeholder methods
- TASK-003-017 (Dashboard) will consume `ParsedResults`

---

## Documentation Requirements

- JSDoc for all interfaces and public methods
- Usage examples in comments
- Migration guide if refactoring existing parser

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| ORCA format changes | Medium | High | Use defensive parsing, multiple patterns |
| Performance with large outputs | Low | Medium | Parse only needed sections, lazy evaluation in future |
| Breaking existing functionality | Low | High | Maintain backward compatibility, extensive testing |

---

## Completion Checklist

- [ ] All interfaces defined
- [ ] Parser class created
- [ ] Basic extraction methods implemented
- [ ] File reading works
- [ ] Test cases pass
- [ ] TypeScript compiles
- [ ] JSDoc complete
- [ ] Ready for TASK-003-012 to 003-015

---

**Notes**:
- This is a foundational task for Phase 3
- Subsequent tasks will implement the placeholder methods
- Focus on clean architecture and extensibility
